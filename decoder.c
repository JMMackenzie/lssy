/* Reads a file of arithmetic coded bytes generated by encoder.
   Uses the same bins file (that was created by quantize.c from a
   completely sorted input file of 32-bit floats and then used by
   encoder.c) to know a frequency distribution and to learn the
   surrogate floating point values that should be generated for each
   bin number decoded.

   Written by Alistair Moffat (The University of Melbourne) as part
   of the paper "Lossy Compression Options for Dense Index Retention"
   at SIGIR-AP 2023.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <assert.h>

/* yes, doing it this way is a bit ugly, but also convenient */
#include "helpers.c"

int
main(int argc, char *argv[]) {

	FILE *fb=NULL, *fi=NULL, *fo=NULL;
	int i;

	if ((argc<4) ||
		(fb=fopen(argv[1], "r")) == NULL ||
		(fi=fopen(argv[2], "r")) == NULL ||
		(fo=fopen(argv[3], "w")) == NULL) {
		fprintf(stderr, "Usage: %s binsfile.bin compressed.bin"
			" index-out.bin\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	make_arrays_and_read_bin_data(fb);
	fprintf(stderr, "read descriptions for %lu bins, ", num_bins);
        fprintf(stderr, "covering %zu symbols\n", total);

	/* should now be in synch with the encoder
	*/

	/* ok, have the bin data, next step is to copy over the
	   is a sequence of float values, each must be searched for
	   and mapped to a bin number */

	if (fread(head, sizeof(*head), HEADER, fi) != 1) {
    read_error();
  }
	fwrite(head, sizeof(*head), HEADER, fo);

	size_t cnt=0;
	size_t v;

	decoder_start(fi);

	for (i=0; i<total; i++) {
		v = arith_decode(c, num_bins, fi);
		fwrite(S+v, sizeof(float), 1, fo);
		cnt++;
	}

	fclose(fo);
	fprintf(stderr, "expanded %lu codes for quantized floats\n", cnt);
	return 0;
}
